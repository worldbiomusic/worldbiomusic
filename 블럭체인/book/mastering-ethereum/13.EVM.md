# EVM
- Ethereum Virtual Machine
- 가상의 기계
- 이더리움의 스마트 컨트랙트와 관련된 동작을 처리해주는 기계 (간단한 송금 트랜잭션 같은 경우는 EVM이 필요없지만, 복잡한 동작같은 경우는 필요)
- 이더리움 블럭체인은 EVM 위에서 동작

# 특징
- 유사 튜링 완전 상태 머신 (quasi-turing-complete state machine): 튜링 완전을 유사하게 구현하는 상태 기반의 머신
- EVM은 일반적인 고급언어처럼 대부분의 동작을 수행할 수 있어 유사 튜링 완전 머신이다
- 동시에 네트워크의 정상적인 동작을 위해서EVM의 동작단위에 Gas비용을 부과해서 정지 문제를 해결함
- Stack-based: register-based 보다 구현하기 용이해서 선택
- 256bit 기본 사용: hash관련 작업이 많기 때문

# 구성요소
- 프로그램 코드 ROM: smart contract의 bytecode가 저장됨 (계정이 smart contract일 때만 존재)
- Memory
- Storage (계정이 smart contract일 때만 존재 (영구 데이터 저장소))
- environment variables, data and etc

# 가상 머신
- JVM과 유사하게 추상화
- 월드 컴퓨터지만 단일 스레드처럼 동작
- 어떠한 하드웨어 지원(이더리움 -> 하드웨어)없이 완전한 가상 환경의 컴퓨터

# 명령어
- 산술, 비트논리
- 컨텍스트 조회
- 스택, 메모리, 스토리지
- 흐름 제어
- 로그, 호출

그림

# 상태
- transaction-based state machine: 이더리움은 스마트 컨트랙트 코드의 유효한 실행(tx에 의해 실행 되는 것이므로)으로 인해 상태가 변화됨 (사용자, 채굴자들에 의해)
- World state: 계정을 상태(잔액, 논스, 스토리지 등)로서 운영함 (이더리움은 상태 기반 머신 이므로) (추상화가 아닌 기본 protocol layer에 존재)

# 스마트 컨트랙트 실행
- 실행시 스마트 컨트랙트를 인스턴스 화
- 가스부족(Out Of Gas)이 발생하면 해당 시점까지 수행된 gas 비용은 채굴자에게 전달되고 해당 트랜잭션은 삭제됨
- 호출당한 컨트랙트는 호출한 컨트랙트의 EVM상태 기반으로 실행됨

# Soldity 컴파일
- 그림(347-1)
- `solc -o dir --opcodes a.sol`: opcode로 컴파일
- 그림(347-2)
- `solc -o dir --bin a.sol`: bytecode로 컴파일
- 그림(348-2)

- `PUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE`
- 0x60과 0x40을 차래대로 stack에 push
- MSTORE가 stack에서 pop을 해서 첫번째 인자값 메모리 주소에 두번째 인자 값을 저장한다

# 컨트랙트 배포
- `배포 바이트코드`: 배포를 위해 초기화 코드가 포함됨
- `런타임 바이트코드`: 단순 실행 코드만 포함됨
- `런타임 바이트코드`는 `배포 바이트코드`안에 포함되는 관계

# 바이트 코드 디어셈블링
```
PUSH1 0x4
CALLDATASIZE
LT
PUSH1 0x3f
JUMPI
```
1. push 0x4 
2. push calldata length
3. calldata length가 4보다 작은지 비교 (함수는 해쉬의 처음 4바이트만 사용되기 때문: 아니면 fallback 또는 exceptoin호출 ): 작으면 1, 크면 0 push
4. push 0x3f (fallback 함수)
5. jumpif(0x3f, 1): 현재는 작은것으로 가정해서 fallback함수를 호출하며 컨트랙트가 종료됨

- 함수도 스택에 들어가서 비슷한 원리로 동작

# 튜링 완전 & 가스
- 튜링 완전은 어떤 문제라도 풀 수 있다
- 보통 문제를 해결할 때 반복문으로 조건검사를 하는 형태로 많이 해결한다
- 튜링 완전의 프로그램의 문제점은 영원히 실행될 수 있는 문제가 있다
- 이것은 정지문제(halting problem)이라고 불린다

- 이더리움은 스케쥴러가 없어 무한 루프에 빠지면 빠져나올 수 없다
- 그러므로 프로그램 실행에 대한 비용(gas)을 부과해서 정지문제를 해결한다: 유사 튜링 완전 머신

# 가스
- 비트코인: 트랜잭션의 크기
- 이더리움: 트랜잭션의 크기 + 컨트랙트 코드 수행 가스
- 프로그램의 각 연산 코드에는 고정된 가스 비용이 소비된다 (예. 트랜잭션 전송 비용: 21,000 gas)
- 정지문제 해결, 채굴자의 보상 역할

# 가스 계산
- 트랜잭션의 sender는 gas 비용과 gas 가격을 지불
```yaml
gas cost: contract실행에 부과되는 gas 개수
gas price(fee): 1gas당 가격 (ether)
```
- EVM은 컨트랙트를 실행하면서 가스 한도를 넘으면 실행 중지하고, 상태 변경하지 않음 (실행한 시점까지의 비용은 채굴자에게 이더로 변환되어 보상)
- `채굴 비용` = `가스 비용` + `가스 가격`

- 만약 컨트랙트 실행 후 가스가 남았다면 sender에게 되돌려줌
- `남은 가스` = `가스 한도` - `가스 비용`
- 남은 가스는 지불할 때의 가스가격으로 이더로 변환되어 지급됨)

# 가스 계산
- 프로그램 연산 코드의 가스 비용은 상대적으로 명시됨
- `연산 코드의 실행 비용`과 `가스 비용`의 일치시키는 작업은 굉장히 중요 (공격으로 사용될 수 있음)

# 네거티브 가스 비용
- 이더리움은 저장되있는 데이터와 계정을 삭제하면 가스를 환불해 줌
1. 컨트랙트 삭제: 24,000 가스 환불
2. 컨트랙트 storage 주소를 0으로 해서 데이터 삭제: 15,000 가스 환불

- 환불 매커니즘 악용을 막기 위해 트랜잭션의 최대 환불액은 지급한 가스양의 절반으로 설정됨
> 악용 예시. 1000가스로 컨트랙트를 만들고, 100가스가 담긴 트랜잭션을 전송해 트랜잭션을 SELFDESTRUCT해서 21000 가스를 얻는 악용 가능)

# 블럭 가스 한도
- 이더리움은 블럭크기는 시장에 의해 변동된다
- 블럭의 모든 tx가 가질 수 있는 가스 양의 합의 최대치만큼의 크기로 블럭의 크기가 결정됨
- tx의 사용 가스 비용과 포함될 수 있는 tx개수는 반비례 관계
- 2022.1 기준 블럭 가스 한도: 30 million gas (기본 송금 tx(21000 gas)는 약 1400개 들어감)
- 블럭 가스 한도가 늘어나면 gas fee의 평균은 줄어듬, (블럭 채굴 속도에 영향이 있지 않나?)

## 블럭 가스 한도 결정
- 프로토콜 내에 블럭 가스 한도 투표 매커니즘 내장
- 어느 방향으로든 1/1024 비율로 투표 가능
- 블럭당 최근 총 가스 사용량의 평균 150%를 목표로 함
- Q. 무조건 150%씩 변경됨? 아니면 수치 지정 가능?




